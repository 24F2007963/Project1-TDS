{
  "source": "tools-in-data-science-public\\hybrid-rag-typesense.md",
  "type": "course",
  "text": "## Hybrid Retrieval Augmented Generation (Hybrid RAG) with TypeSense\n\nHybrid RAG combines semantic (vector) search with traditional keyword search to improve retrieval accuracy and relevance. By mixing exact text matches with embedding-based similarity, you get the best of both worlds: precision when keywords are present, and semantic recall when phrasing varies. [TypeSense](https://typesense.org/) makes this easy with built-in hybrid search and automatic embedding generation.\n\nBelow is a fully self-contained Hybrid RAG tutorial using TypeSense, Python, and the command line.\n\n### Install and run TypeSense\n\n[Install TypeSense](https://typesense.org/docs/guide/install-typesense.html).\n\n```bash\nmkdir typesense-data\n\ndocker run -p 8108:8108 \\\n  -v typesense-data:/data typesense/typesense:28.0 \\\n  --data-dir /data \\\n  --api-key=secret-key \\\n  --enable-cors\n```\n\n- **`docker run`**: spins up a containerized TypeSense server on port 8108\n  - `-p 8108:8108` maps host port to container port.\n  - `-v typesense-data:/data` mounts a Docker volume for persistence.\n  - `--data-dir /data` points TypeSense at that volume.\n  - `--api-key=secret-key` secures your API.\n  - `--enable-cors` allows browser-based requests.\n\n**Expected output:**\n\n- Docker logs showing TypeSense startup messages, such as `Started Typesense API server`.\n- Listening on `http://0.0.0.0:8108`.\n\n### Embed and import documents into TypeSense\n\nFollow the steps in the [RAG with the CLI](rag-cli.md) tutorial to create a `chunks.json` that has one `{id, content}` JSON object per line.\n\n[TypeSense supports automatic embedding of documents](https://typesense.org/docs/28.0/api/vector-search.html#option-b-auto-embedding-generation-within-typesense). We'll use that capability.\n\nSave the following as `addnotes.py` and run it with `uv run addnotes.py`.\n\n```python\n# /// script\n# requires-python = \">=3.13\"\n# dependencies = [\"httpx\"]\n# ///\nimport json\nimport httpx\nimport os\n\nheaders = {\"X-TYPESENSE-API-KEY\": \"secret-key\"}\n\nschema = {\n    \"name\": \"notes\",\n    \"fields\": [\n        {\"name\": \"id\", \"type\": \"string\", \"facet\": False},\n        {\"name\": \"content\", \"type\": \"string\", \"facet\": False},\n        {\n            \"name\": \"embedding\",\n            \"type\": \"float[]\",\n            \"embed\": {\n                \"from\": [\"content\"],\n                \"model_config\": {\n                    \"model_name\": \"openai/text-embedding-3-small\",\n                    \"api_key\": os.getenv(\"OPENAI_API_KEY\"),\n                },\n            },\n        },\n    ],\n}\n\nwith open(\"chunks.json\", \"r\") as f:\n    chunks = [json.loads(line) for line in f.readlines()]\n\nwith httpx.Client() as client:\n    # Create the collection\n    if client.get(f\"http://localhost:8108/collections/notes\", headers=headers).status_code == 404:\n        r = client.post(\"http://localhost:8108/collections\", json=schema, headers=headers)\n\n    # Embed the chunks\n    result = client.post(\n        \"http://localhost:8108/collections/notes/documents/import?action=emplace\",\n        headers={**headers, \"Content-Type\": \"text/plain\"},\n        data=\"\\n\".join(json.dumps(chunk) for chunk in chunks),\n    )\n    print(result.text)\n```\n\n- **`httpx.Client`**: an HTTP client for Python.\n- **Collection schema**: `id` and `content` fields plus an `embedding` field with auto-generated embeddings from OpenAI.\n- **Auto-embedding**: the `embed` block instructs TypeSense to call the specified model for each document.\n- **`GET /collections/notes`**: checks existence.\n- **`POST /collections`**: creates the collection.\n- **`POST /collections/notes/documents/import?action=emplace`**: bulk upsert documents, embedding them on the fly.\n\n**Expected output:**\n\n- A JSON summary string like `{\"success\": X, \"failed\": 0}` indicating how many docs were imported.\n- (On timeouts, re-run until all chunks are processed.)\n\n### 4. Run a hybrid search and answer a question\n\nNow, we can use a single `curl` against the Multi-Search endpoint to combine keyword and vector search as a [hybrid search](https://typesense.org/docs/28.0/api/vector-search.html#hybrid-search):\n\n```bash\nQ=\"What does the author affectionately call the => syntax?\"\n\npayload=$(jq -n --arg coll \"notes\" --arg q \"$Q\" \\\n  '{\n     searches: [\n       {\n         collection: $coll,\n         q:           $q,\n         query_by:    \"content,embedding\",\n         sort_by:     \"_text_match:desc\",\n         prefix:      false,\n         exclude_fields: \"embedding\"\n       }\n     ]\n   }'\n)\ncurl -s 'http://localhost:8108/multi_search' \\\n  -H \"X-TYPESENSE-API-KEY: secret-key\" \\\n  -d \"$payload\" \\\n  | jq -r '.results[].hits[].document.content' \\\n  | llm -s \"${Q} - \\$Answer ONLY from these notes. Cite verbatim from the notes.\" \\\n  | uvx streamdown\n```\n\n- **`query_by: \"content,embedding\"`**: tells TypeSense to score by both keyword and vector similarity.\n- **`sort_by: \"_text_match:desc\"`**: boosts exact text hits.\n- **`exclude_fields: \"embedding\"`**: keeps responses lightweight.\n- **`curl -d`**: posts the search request.\n- **`jq -r`**: extracts each hit\u2019s `content`. See [jq manual](https://stedolan.github.io/jq/manual/)\n- **`llm -s`** and **`uvx streamdown`**: generate and stream a grounded answer.\n\n**Expected output:**\n\n- The raw matched snippets printed first.\n- Then a concise, streamed LLM answer citing the note verbatim.\n"
}